# MySQL数据库结构设计

需求分析、逻辑设计、物理设计、维护优化  
## 数据库设计范式：
三范式  
### 第一范式：
- 表中中的所有字段都只具有单一属性
- 单一属性的列是由基本的数据类型所构成的
- 设计出来的表都是简单的二维表

### 第二范式：
一个表中只具有一个业务主键，也就是说表中不能存在非主键列只对部分主键地依赖关系。

### 第三范式：
每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主属性对主键的传递依赖。

反范式化  
为了性能和读取效率的考虑而适当的对数据库设计范式的要求进行违反，允许存在少量的数据冗余，换句话说就是使用空间来换取时间。
 

### 字段类型选择
一个列可以选择多种数据类型时，应该优先考虑数字类型，其次是日期和二进制类型，最后是字符类型。相同的级别的类型应该先选择空间小的类型

### 整数类型
| 类型 | 存储空间 | 取值范围signed | unsigned |
|tinyint | 1字节 | -128~127 | 255 |
|smallint | 2字节 |  | 65535 |
int | 4字节 | -2147483648~2147483647 |  |
bigint | 8字节 |  |  |

### 实数类型
| 类型 | 存储空间 | 是否精确类型 | 
| float | 4字节 | 否|
| double | 8字节 | 否|
| decimal | 每4个字节存9个数字，小数点占1个字节 | 是 |
decimal(18,9)需要9个字节，适合存储财务类型

### varchar:
变长字符串，只占用实际长度的空间。列长<255只占用一个额外字节记录字符串长度，>255占用两个字节记录长度。innodb中一行所有共享的长度是65535。
使用最小的符合需求的长度，<5.7修改varchar列长度需要锁表，>5.7时如果修改的长度不超过255时不锁表
varchar(5)的性能高于varchar(200)，内存中使用的是固定的长度，列更长会消耗更多内存。(p117)  
使用场景：  
- 字符串的最大长度要比平均长度大很多
- 字符串列很少更新，更新长度会引起存储列的分列。
- 使用了多字节字符集存储字符串

### char类型：  
定长，会删除末尾的空格，最大长度是255
使用场景：  
- 存储长度近似的值 如：md5、身份证、手机号等固定长度的。
- 适合存储短字符串
- 适合经常更新的字符串

### datetime类型
存储日期时间，与时区无关，时间范围1000-01-01 00:00:00到9999-12-31 23:59:59

### timestamp
时间戳，从1970-01-01到2038-01-19,存储空间小于datetime，依赖于指定的时区，默认只有第一个timestamp列，在行的内容修改时自动更新时间

### date和time类型 date占3个字节
>5.7以后加入date类型

innodb选择主键：主键尽量小，应该是自增，主键和业务主键可以不同，业务主键上添加唯一索引。

### 计数器表
计数器选择独立的表比较好。为避免高并发下的全局互斥锁(mutex)，把串行改为并行，可以将计数器保存在多行中，每次随机跟新一行。(p135)
insert into daily_hit_counter(day, slot, cnt)
    -> values (current_date, rand() * 100, 1)
    -> on dulicate key update cnt = cnt + 1;




